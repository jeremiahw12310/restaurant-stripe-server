rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    // IMPORTANT: Firestore Security Rules cannot reliably identify Admin SDK / server traffic.
    // Admin SDK bypasses rules entirely. Treat all requests here as client-originated.
    function isServer() {
      return false;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isPostOwner(postUserId) {
      return isAuthenticated() && request.auth.uid == postUserId;
    }
    
    function userCreateIsSafe(userId) {
      // Allow initial user doc creation at signup, but prevent privilege/points injection.
      return isOwner(userId) &&
        // If these fields are provided at create time, they must be safe defaults.
        (!request.resource.data.keys().hasAny(['isAdmin', 'isEmployee', 'isVerified', 'oldReceiptTestingEnabled']) ) &&
        (request.resource.data.points == 0) &&
        (request.resource.data.hasReceivedWelcomePoints == false) &&
        (request.resource.data.isNewUser == true) &&
        // If lifetimePoints is provided, it must start at 0.
        (!request.resource.data.keys().hasAny(['lifetimePoints']) || request.resource.data.lifetimePoints == 0) &&
        // If uid field exists, it must match document id.
        (!request.resource.data.keys().hasAny(['uid']) || request.resource.data.uid == userId);
    }

    function userSelfUpdateIsSafe() {
      // Allow owners to update only "profile/preferences" fields; never points/admin flags/referral identifiers.
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly([
        'firstName',
        'lastName',
        'birthday',
        'phone',
        'likesSpicyFood',
        'dislikesSpicyFood',
        'hasPeanutAllergy',
        'isVegetarian',
        'hasLactoseIntolerance',
        'doesntEatPork',
        'tastePreferences',
        'hasCompletedPreferences',
        'hasFcmToken',
        'fcmToken',
        'fcmTokenUpdatedAt'
      ]);
    }

    // Users collection - users can read their own profile, admins can read all
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create: if userCreateIsSafe(userId) || isAdmin();
      allow update: if isAdmin() || (isOwner(userId) && userSelfUpdateIsSafe());
      allow delete: if isOwner(userId) || isAdmin();
      
      // User activity subcollection
      match /activity/{activityId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }

      // Client state subcollection (device-agnostic UI acknowledgements)
      // Used for things like "referral bonus seen" markers so popups don't repeat on new devices/reinstalls.
      match /clientState/{docId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }
    }
    
    // Posts collection - public read, authenticated users can create, owners can edit/delete
    match /posts/{postId} {
      allow read: if true; // Public read for all posts
      allow create: if isAuthenticated(); // Any authenticated user can create posts
      allow update, delete: if isPostOwner(resource.data.userId) || isAdmin(); // Only post owner or admin can edit/delete
      
      // Post likes subcollection
      match /likes/{likeId} {
        allow read: if true; // Public read for likes
        allow write: if isAuthenticated() && likeId == request.auth.uid; // Users can only manage their own likes
      }
      
      // Post replies subcollection
      match /replies/{replyId} {
        allow read: if true; // Public read for replies
        allow create: if isAuthenticated(); // Any authenticated user can create replies
        allow update, delete: if isAuthenticated() && 
          (resource.data.userId == request.auth.uid || isAdmin()); // Only reply owner or admin can edit/delete
      }
      
      // Post reactions subcollection
      match /reactions/{reactionId} {
        allow read: if true; // Public read for reactions
        allow write: if isAuthenticated() && reactionId == request.auth.uid; // Users can only manage their own reactions
      }
    }
    
    // Collection group queries for replies and likes
    match /{path=**}/replies/{replyId} {
      allow read: if true; // Public read for all replies across all posts
      allow create: if isAuthenticated(); // Any authenticated user can create replies
      allow update, delete: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || isAdmin()); // Only reply owner or admin can edit/delete
    }
    
    match /{path=**}/likes/{likeId} {
      allow read: if true; // Public read for all likes across all posts
      allow write: if isAuthenticated() && likeId == request.auth.uid; // Users can only manage their own likes
    }
    
    // Crowd meter collection - public read, admin write
    match /crowdMeter/{document} {
      allow read: if true; // Public read for crowd levels
      allow write: if isAdmin(); // Only admins can update crowd levels
    }
    
    // Menu collection - public read, admin write
    match /menu/{categoryId} {
      allow read: if true; // Public read for menu categories
      allow write: if isAdmin(); // Only admins can modify menu categories
      
      // Menu items subcollection
      match /items/{itemId} {
        allow read: if true; // Public read for menu items
        allow write: if isAdmin(); // Only admins can modify menu items
      }
      
      // Toppings subcollection
      match /toppings/{toppingId} {
        allow read: if true; // Public read for toppings
        allow write: if isAdmin(); // Only admins can modify toppings
      }
    }
    
    // Analytics collection - admin only
    match /analytics/{document} {
      allow read, write: if isAdmin(); // Only admins can access analytics
    }
    
    // Reports collection - admin only
    match /reports/{reportId} {
      allow read, write: if isAdmin(); // Only admins can access reports
    }
    
    // Admin actions collection - admin only
    match /adminActions/{actionId} {
      allow read, write: if isAdmin(); // Only admins can access admin actions
    }
    
    // Notifications collection - users can read their own, admins can read all
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || isAdmin());
      allow write: if isAdmin(); // Only admins can create notifications
    }
    
    // Sent notifications audit log - admin only
    match /sentNotifications/{notificationId} {
      allow read, write: if isAdmin(); // Only admins can access notification history
    }
    
    // Verification requests collection - admin only
    match /verificationRequests/{requestId} {
      allow read, write: if isAdmin(); // Only admins can access verification requests
    }
    
    // Points transactions collection - users can read their own; writes are admin/server only
    match /pointsTransactions/{transactionId} {
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
      allow write: if isAdmin();
    }
    
    // Drink flavors collection - public read, admin write
    match /drinkFlavors/{flavorId} {
      allow read: if true; // Public read for drink flavors
      allow write: if isAdmin(); // Only admins can modify drink flavors
    }
    
    // Drink options collection - public read, admin write
    match /drinkOptions/{optionId} {
      allow read: if true; // Public read for drink options
      allow write: if isAdmin(); // Only admins can modify drink options
    }
    
    // Drink toppings collection - public read, admin write
    match /drinkToppings/{toppingId} {
      allow read: if true; // Public read for drink toppings
      allow write: if isAdmin(); // Only admins can modify drink toppings
    }

    // Allergy tags collection - public read, admin write
    match /allergyTags/{tagId} {
      allow read: if true; // Public read so customers can see allergy labels
      allow write: if isAdmin(); // Only admins can create/update/delete allergy tags
    }
    
    // Menu order collection - public read, admin write
    match /menuOrder/{document} {
      allow read: if true; // Public read for menu order (allows all users to see ordered menu)
      allow write: if isAdmin(); // Only admins can modify menu order
    }
    
    // Config collection - admin only
    match /config/{document} {
      allow read, write: if isAdmin(); // Only admins can modify config
    }
    
    // Used receipts collection
    // NOTE: Receipt submission is now server-authoritative; clients must not read/write this collection.
    match /usedReceipts/{receiptId} {
      allow read, write: if false;
    }
    
    // Receipt scan attempts collection - server-only for rate limiting
    match /receiptScanAttempts/{attemptId} {
      allow read, write: if false;  // Server-only
    }
    
    // Receipts collection - server creates, users can read/anonymize their own for account deletion
    match /receipts/{receiptId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      // Allow users to anonymize their own receipts (update only PII fields)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userName', 'userPhone', 'userEmail']);
      allow create, delete: if false; // Server-only
    }
    
    // Gifted rewards collection - server creates, users can update if they're a target
    match /giftedRewards/{rewardId} {
      allow read: if isAuthenticated() && request.auth.uid in resource.data.targetUserIds;
      // Allow users to remove themselves from targetUserIds (account deletion cleanup)
      allow update: if isAuthenticated() && 
        request.auth.uid in resource.data.targetUserIds &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['targetUserIds']);
      allow create, delete: if false; // Server-only
    }
    
    // Gifted reward claims collection - server creates, users can read/anonymize their own
    match /giftedRewardClaims/{claimId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      // Allow users to anonymize their own claims (update only PII fields)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userName', 'userPhone']);
      allow create, delete: if false; // Server-only
    }
    
    // Redeemed rewards collection - readable by any authenticated user for verification purposes.
    match /redeemedRewards/{rewardId} {
      // Any signed-in user (e.g., employee) can READ reward documents.
      // Backend (Admin SDK) reads are allowed via isServer().
      allow read: if isAuthenticated();

      // Writes remain restricted to the reward owner, admins, or backend server.
      // (Keep broad write permissions here as originally implemented to avoid breaking reward flows.)
      allow write: if (isAuthenticated() && (request.auth.uid == resource.data.userId || isAdmin()));
    }

    // Referrals: server/admin write-only; limited reads
    match /referralCodes/{code} {
      // Codes are managed by server; no direct client writes
      allow read: if isAdmin();
      allow write: if isAdmin();
    }

    match /referrals/{referralId} {
      // Read if user is the referrer or the referred, or admin/server
      allow read: if (isAuthenticated() && (
          (resource.data.referrerUserId == request.auth.uid) ||
          (resource.data.referredUserId == request.auth.uid) ||
          isAdmin()
        ));
      // Writes server/admin only
      allow write: if isAdmin();
    }

    // IP usage counters for abuse prevention - server/admin only
    match /referralIpUsage/{dayIp} {
      allow read, write: if isAdmin();
    }
    
    // Promo slides collection - public read, admin write
    match /promoSlides/{slideId} {
      allow read: if true; // Public read for promo slides
      allow write: if isAdmin(); // Only admins can manage promo slides
    }
    
    // Banned numbers collection - public read for ban check (pre-auth), admin write
    match /bannedNumbers/{phone} {
      allow read: if true; // Public read for ban check before sign-in
      allow write: if isAdmin(); // Only admins can ban/unban
    }
    
    // Suspicious flags collection - admin only
    match /suspiciousFlags/{flagId} {
      allow read: if isAdmin(); // Only admins can view flags
      allow write: if false; // Server-only writes
    }
    
    // Banned account history collection - admin only
    // Stores archived user data for 24 hours after a banned user deletes their account
    match /bannedAccountHistory/{historyId} {
      allow read: if isAdmin(); // Only admins can view banned account history
      allow write: if false; // Server-only writes via Admin SDK
    }
    
    // User risk scores collection - admin only
    match /userRiskScores/{userId} {
      allow read: if isAdmin(); // Only admins can view risk scores
      allow write: if false; // Server-only writes
    }
    
    // Device fingerprints collection - server-only
    match /deviceFingerprints/{hash} {
      allow read, write: if false; // Server-only
    }

    // Abuse prevention hashes - phone hashes for welcome/referral abuse prevention (server-only)
    match /abusePreventionHashes/{hash} {
      allow read, write: if false; // Server-only
    }

    // Referral pairs - phone hash pairs to prevent duplicate referrals after account deletion (server-only)
    match /referralPairs/{pairId} {
      allow read, write: if false; // Server-only
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
} 